{"name":"AccessRank","tagline":"","body":"AccessRank\r\n==========\r\n\r\n### About AccessRank\r\n\r\n*AccessRank* is a Swift implementation of the [AccessRank algorithm by Fitchett and Cockburn](http://www.cosc.canterbury.ac.nz/andrew.cockburn/papers/AccessRank-camera.pdf) (full reference below) for iOS and Mac OS apps. The algorithm predicts which list items users might select or visit next by taking multiple sources of input into account. For instance, you could use *AccessRank* to generate a list of predictions for:\r\n- which documents a user is most likely to open next.\r\n- which commands in an auto-complete menu might be triggered next.\r\n- which fonts in a font-chooser widget might be selected next.\r\n- basically every part in a user interface where reuse or revisitation of things is involved...\r\n\r\nTo improve on other common methods such as recency-based and frequency-based predictions, *AccessRank* adds Markov weights, time weighting, and other parameters for calculating a final score for each item, while the algorithm tries to maximize both prediction accuracy and list stability. Prediction accuracy is important since top items are easier and faster to access than items in bottom sections; list stability is important since automatic reordering of items can impede usability when users try to reselect an item based on an already learned location. You can configure the algorithm depending on whether you prefer more prediction accuracy or more list stability.\r\n\r\nOnce *AccessRank* has calculated predictions, you can use the resulting list to enhance your user interface in various ways. For example, you could display the most likely next items in an additional list as suggestions, or you could visually highlight relevant objects to give users cues where they might want to go next.\r\n\r\nHere's the full reference for the [paper](http://www.cosc.canterbury.ac.nz/andrew.cockburn/papers/AccessRank-camera.pdf):\r\n\r\n> Stephen Fitchett and Andy Cockburn. 2012. AccessRank: predicting what users will do next. In Proceedings of the SIGCHI Conference on Human Factors in Computing Systems (CHI '12). ACM, New York, NY, USA, 2239-2242.\r\n\r\nThanks to Stephen Fitchett for answering my questions and giving feedback!\r\n\r\n### Installation\r\n\r\nJust copy the folder `src/AccessRank` into your project. \r\n\r\n### Demo Project\r\n\r\nThe demo project shows a simple usage example: It contains a table view with item names and a text view with predictions. When you select an item, it is added to *AccessRank*, and the list of predictions for which item you might select next is updated. When the app is moved to the background state, an *AccessRank* snapshot is saved to the user defaults (also see the section on persistence).\r\n*Note*: The example doesn't use auto-layout due to some obscure bugs in Xcode 6 beta 3.\r\n\r\n### Usage\r\n\r\nDue to the Swift language currently lacking access modifiers, basically everything in AccessRank.swift is *public* (This will be changed as soon as Swift includes access modifiers in a later release.). The properties and methods which are supposed to be used by clients are documented here.\r\n\r\n#### Initializing\r\n\r\n*AccessRank* is initialized with an enum value for the list stability that should be used for predictions. The default list stability is `.ListStability.Medium`. Other possible values are `.ListStability.Low` and `.ListStability.High`. *Low* stability means that prediction accuracy should be maximized while items are allowed to be reordered more than with other values. *High* stability means that the ordering of items should remain as stable as possible so that users can better learn item locations over time. The appropriate value to use here depends on your application domain. *Medium* stability is the default value and should be used if you are insecure which one to choose.  \r\n(Also see the three unit tests on list stability in `AccessRankTests.swift` to get an idea on how this value affects predictions.)\r\n\r\n```swift\r\nlet accessRank = AccessRank(listStability: AccessRank.ListStability.Medium)\r\n```\r\n\r\n#### Configuration\r\n\r\nThe only feature you can currently configure is turning *time weighting* on and off. The *time weighting* component of *AccessRank* takes the time of day and weekday into account. Put simply, items are given more weight when they are revisited in roughly the same time slot as previously. If you don't need time weighting in your application domain, you should turn this feature off to increase performance.\r\n\r\n```swift\r\naccessRank.useTimeWeighting = false\r\n```\r\n\r\n#### Visiting Items\r\n\r\nVisiting items is as simple as calling the method `visitItem` with an item id. You should call this method whenever a user selects an item in the list (i.e., visits or uses the item). The parameter is an `optional` so that you can pass `nil` when the user deselects an item.\r\n\r\n```swift\r\naccessRank.visitItem(\"A\")\r\n```\r\n\r\n#### Most Recent Item\r\n\r\nCalling the property getter `mostRecentItem` returns the most recently visited item id as an `optional`.\r\n\r\n```swift\r\nprintln(\"mostRecentItem: \\(accessRank.mostRecentItem)\")\r\n```\r\n\r\n#### Removing Items\r\n\r\nIf your list is dynamic and items might be removed in response to user interaction, you can remove previously added items by calling `removeItems` and passing the method an array of ids to be removed.\r\n\r\n```swift\r\naccessRank.removeItems([\"A\", \"B\"])\r\n```\r\n\r\n#### Predictions\r\n\r\nThe `predictions` property getter returns the current predictions as an array containing all your item ids (the ones you previously set using `mostRecentItem`) in sorted order. The first item in the array is the most likely next item. To display the predicted items somewhere in the user interface, these ids can then be matched to the item ids of your own list data structure. \r\n\r\n```swift\r\nprintln(\"predictions: \\(accessRank.predictions)\")\r\n```\r\n\r\n#### Delegate Methods\r\n\r\nThe delegate method `accessRankDidUpdatePredictions(accessRank: AccessRank)` is called whenever the predictions are updated. Predictions are updated when you set `mostRecentItem`, or when you call `removeItems`.\r\n\r\n```swift\r\naccessRank.delegate = self\r\n\r\nfunc accessRankDidUpdatePredictions(accessRank: AccessRank) {\r\n    println(\"predictions: \\(accessRank.predictions)\")\r\n}\r\n```\r\n\r\n#### Persistence\r\n\r\nIf you want to persist the current *AccessRank* data in your application beyond a single session, you can use the `toDictionary` method to get a snapshot of the data structure as dictionary for storage. The simplest solution is to store this dictionary in the user defaults (see the example app). You could also convert it to JSON and store it on a server, or in Core Data etc. \r\n\r\nOnce you have stored the data, you can restore *AccessRank* by setting the dictionary as second parameter in the initializer:\r\n\r\n```swift\r\nlet dataToPersist = accessRank.toDictionary()\r\n        \r\nlet restoredAccessRank = AccessRank(\r\n    listStability: AccessRank.ListStability.Medium,\r\n    data: dataToPersist)\r\n```\r\n\r\n### Unit Tests\r\n\r\nAlthough there's no exhaustive test coverage, a couple of unit tests in `AccessRankTests.swift` should at least make sure that the basics work. If you change the implementation of `AccessRank.swift`, make sure that all tests still pass or, even better, add new tests ;).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}